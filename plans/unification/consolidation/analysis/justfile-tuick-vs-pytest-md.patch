--- /Users/david/code/tuick/justfile	2026-01-03 15:34:21
+++ /Users/david/code/pytest-md/justfile	2026-01-16 15:45:18
@@ -1,224 +1,269 @@
-# Tuicker project commands
+# Justfile Rules:
+# - Errors should not pass silently without good reason
+# - Only use `2>/dev/null` for probing (checking exit status when command has no quiet option)
+# - Only use `|| true` to continue after expected failures (required with `set -e`)
+# Enable bash tracing (set -x) for all recipes. Usage: just trace=true <recipe>
 
-# Display available recipes
-[group('user')]
+trace := "false"
+
+# List available recipes
 help:
     @just --list --unsorted
 
-# Install tuick using uv tool
-[group('user')]
-install:
-    uv tool install --refresh-package tuick file://.
+# Full development workflow
+[no-exit-message]
+dev: format check test
 
-# Common variables
+# Run test suite
+[no-exit-message]
+test *ARGS:
+    #!{{ bash_prolog }}
+    sync
+    pytest {{ ARGS }}
 
-[private]
-_run-dev := 'uv run --dev'
-[private]
-_python-dirs := "src tests scripts"
-[private]
-_pytest-opts := "--no-header --tb=short"
+# Run token efficiency benchmark
+[no-exit-message]
+benchmark MODULE="tests/examples.py":
+    #!{{ bash_prolog }}
+    sync
+    python scripts/benchmark.py {{ MODULE }}
 
-# Bash definitions
 
-[private]
-_bash-defs := '''
-run_dev="''' + _run-dev + '''"
-python_dirs="''' + _python-dirs + '''"
-full_diff=''' + full-diff + ''';
-COMMAND="''' + style('command') + '''"
-NORMAL="''' + NORMAL + '''"
-safe () { "$@" || status=false; }
-end-safe () { ${status:-true}; }
-show () { echo "$COMMAND$*$NORMAL"; }
-visible () { show "$@"; "$@"; }
-report () { local s=$?; show "$@"; echo "$out"; return $s; }
-quiet () { out=$("$@" >&1) || report "$@"; }
-pytest-agent-filter () {
-    $full_diff && while read -r line
-    do [[ $line =~ ^===+\ FAILURES\ ===+$ ]] && break; done
-    cat
-}
-tuickf="tuick --format"
-'''
-# Pytest options.
-# Run with full-diff=true for full diffs.
+# Format, check with complexity disabled, test
+[no-exit-message]
+lint: format
+    #!{{ bash_prolog }}
+    sync
+    ruff_ignores=C901,PLR0904,PLR0911,PLR0912,PLR0913,PLR0914,PLR0915,PLR0916,PLR0917,PLR1701,PLR1702
+    report "ruff check" ruff check -q --ignore=$ruff_ignores
+    report "docformatter -c" docformatter -c src tests
+    report "mypy" mypy
+    pytest_hack () {
+        # Bug: pytest -q exits 0 even if tests fail
+        pytest -q > "$tmpfile"
+        if grep -q "^Re-run failed: " "$tmpfile"; then
+            show "# pytest"
+            cat "$tmpfile"
+            return 1
+        fi
+    }
+    safe pytest_hack
+    if end-safe; then
+        echo "${GREEN}‚úì$NORMAL Lint clean"
+    else
+        echo "${RED}‚úó$NORMAL Lint failed"
+        false
+    fi
 
-full-diff := 'false'
-[private]
-_diff-limit-opt := ' -o truncation_limit_lines=7'
-[private]
-_pytest-diff-opt := if full-diff == 'true' { ' --verbose' } else { ' --quiet' + _diff-limit-opt }
-[private]
-_pytest-agent-opts := _pytest-opts + " -p no:icdiff" + _pytest-diff-opt
-
-# Development workflow: check, test, ARGS passed to pytest
-[group('dev')]
-dev *ARGS: _fail_if_claudecode compile
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }} {{ _check-body }}
-    safe visible $run_dev $tuickf -- pytest {{ _pytest-opts }} {{ ARGS }}
+# Check code style
+[no-exit-message]
+check:
+    #!{{ bash_prolog }}
+    sync
+    show "# ruff check"
+    safe ruff check -q
+    show "# docformatter -c"
+    safe docformatter -c src tests
+    show "# mypy"
+    safe mypy
     end-safe
 
-# Agent workflow: check, test with minimal output, ARGS passed to pytest
-[group('agent')]
-agent *ARGS: agent-compile
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }} {{ _agent-check-body }}
-    safe quiet {{ _run-dev }} pytest {{ _pytest-agent-opts }} {{ ARGS }} \
-    | pytest-agent-filter \
-    || $full_diff || echo 'For full diff: just full-diff=true agent"'
-    end-safe && echo OK
+# Format code
+format:
+    #!{{ bash_prolog }}
+    sync
+    tmpfile=$(mktemp tmp-fmt-XXXXXX)
+    trap "rm $tmpfile" EXIT
+    patch-and-print() {
+        patch "$@" | sed -Ene "/^patching file '/s/^[^']+'([^']+)'/\\1/p"
+    }
+    ruff check -q --fix-only --diff | patch-and-print >> "$tmpfile" || true
+    ruff format -q --diff | patch-and-print >> "$tmpfile" || true
+    # docformatter --diff applies the change *and* outputs the diff, so we need to
+    # reverse the patch (-R) and dry run (-C), and it prefixes the path with before and
+    # after (-p1 ignores the first component of the path). Hence `patch -RCp1`.
+    docformatter --diff src tests | patch-and-print -RCp1 >> "$tmpfile" || true
 
-# Clean build files
-[group('dev')]
-clean:
-    rm -rf .venv */__pycache__ */*/__pycache__ build dist list */*.so */*/*.so
+    # Markdown formatting disabled for the moment.
 
-# Clean non-build caches and run files
-[group('dev')]
-clean-cache:
-    rm -rf .dmypy.json .mypy_cache .pytest_cache .ruff_cache
-
-# Fail if CLAUDECODE is set
-[no-exit-message]
-[private]
-_fail_if_claudecode:
-    #!/usr/bin/env bash -euo pipefail
-    if [ "${CLAUDECODE:-}" != "" ]; then
-        echo -e '{{ style("error") }}‚õîÔ∏è Denied: use agent recipes{{ NORMAL }}'
-        exit 1
+    # Must find replacement for dprint that handles backticks correctly.
+    modified=$(sort --unique < "$tmpfile")
+    if [ -n "$modified" ] ; then
+        bold=$'\033[1m'; nobold=$'\033[22m'
+        red=$'\033[31m'; resetfg=$'\033[39m'
+        echo "${bold}${red}**Reformatted files:**"
+        echo "$modified" | sed "s|^|${bold}${red}  - ${nobold}${resetfg}|"
     fi
 
-_python_format := \
-"""-p '%E*** Error ' -p '%C  File "%f", line %l' -p '%C%m' -p '%Z'"""
+# Create release: tag, build tarball, upload to PyPI and GitHub
+# Use --dry-run to perform local changes and verify external permissions without publishing
 
-# Compile python files, quick test for valid syntax
-[group('dev')]
-[private]
-compile:
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }}
-    compile="python3 -m compileall -q $python_dirs"
-    show $run_dev $tuickf -- $compile
-    $run_dev $tuickf {{ _python_format }} -- $compile
-
-# Compile python files, with less output
-[group('agent')]
+# Use --rollback to revert local changes from a crashed dry-run
 [no-exit-message]
-[private]
-agent-compile:
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }}
-    quiet {{ _run-dev }} -m compileall -q {{ _python-dirs }}
+release *ARGS: _fail_if_claudecode dev
+    #!{{ bash_prolog }}
+    DRY_RUN=false
+    ROLLBACK=false
+    BUMP=patch
+    # Parse flags and positional args
+    for arg in {{ ARGS }}; do
+        case "$arg" in
+            --dry-run) DRY_RUN=true ;;
+            --rollback) ROLLBACK=true ;;
+            --*) fail "Error: unknown option: $arg" ;;
+            *) [[ -n "${positional:-}" ]] && fail "Error: too many arguments"
+               positional=$arg ;;
+        esac
+    done
+    [[ -n "${positional:-}" ]] && BUMP=$positional
 
-# Run test suite, ARGS passed to pytest
-[group('dev')]
-test *ARGS: _fail_if_claudecode
-    {{ _run-dev }} tuick --format -- pytest {{ _pytest-opts }} {{ ARGS }}
+    # Cleanup function: revert commit and remove build artifacts
+    cleanup_release() {
+        local initial_head=$1
+        local initial_branch=$2
+        local version=$3
+        visible git reset --hard "$initial_head"
+        if [[ -n "$initial_branch" ]]; then
+            visible git checkout "$initial_branch"
+        else
+            visible git checkout "$initial_head"
+        fi
 
-# Run test suite, with less output, ARGS passed to pytest
-[group('agent')]
-[no-exit-message]
-agent-test *ARGS:
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }}
-    quiet {{ _run-dev }} pytest {{ _pytest-agent-opts }} {{ ARGS }} \
-    | pytest-agent-filter \
-    && { {{ is_dependency() }} || echo OK; } \
-    || { $full_diff || echo 'For full diff: just full-diff=true agent-test';
-         false; }
+        # Remove only this version's build artifacts
+        if [[ -n "$version" ]] && [[ -d dist ]]; then
+            find dist -name "*${version}*" -delete
+            [[ -d dist ]] && [[ -z "$(ls -A dist)" ]] && visible rmdir dist
+        fi
+    }
 
-# Static code analysis and style checks
-[group('dev')]
-check: _fail_if_claudecode compile
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }} {{ _check-body }}
-    end-safe
+    # Rollback mode
+    if [[ "$ROLLBACK" == "true" ]]; then
+        # Check if there's a release commit at HEAD
+        if git log -1 --format=%s | grep -q "üîñ Release"; then
+            # Verify no permanent changes (commit not pushed to remote)
+            # Skip check if HEAD is detached or has no upstream
+            if git symbolic-ref -q HEAD >/dev/null && git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
+                # We're on a branch with upstream - check if release commit is unpushed
+                if ! git log @{u}.. --oneline | grep -q "üîñ Release"; then
+                    fail "Error: release commit already pushed to remote"
+                fi
+            fi
 
-[private]
-_check-body := '''
-    safe visible $run_dev $tuickf -- ruff format --check --quiet $python_dirs
-    safe visible $run_dev $tuickf -p "%E%f" -- docformatter --check $python_dirs
-    safe visible $run_dev $tuickf -- ruff check --quiet $python_dirs
-    safe visible $run_dev $tuickf -- mypy
-    safe visible $run_dev make -C agents check
-'''
+            version=$(git log -1 --format=%s | grep -oP '(?<=Release ).*')
+            current_branch=$(git symbolic-ref -q --short HEAD || echo "")
+            cleanup_release "HEAD~1" "$current_branch" "$version"
+            echo "${GREEN}‚úì${NORMAL} Rollback complete"
+        else
+            fail "No release commit found"
+        fi
+        exit 0
+    fi
 
-# Report TODO, FIXME, XXX, HACK comments
-[group('dev')]
-todo:
-    {{ _run-dev }} ruff check --quiet --ignore ALL --select FIX \
-        {{ _python-dirs }}
+    # Check preconditions
+    git diff --quiet HEAD || fail "Error: uncommitted changes"
+    current_branch=$(git symbolic-ref -q --short HEAD || echo "")
+    [[ -z "$current_branch" ]] && fail "Error: not on a branch (HEAD is detached)"
+    main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
+    [[ "$current_branch" != "$main_branch" ]] && fail "Error: must be on $main_branch branch (currently on $current_branch)"
+    release=$(uv version --bump "$BUMP" --dry-run)
+    tag="v$(echo "$release" | awk '{print $NF}')"
+    git rev-parse "$tag" >/dev/null 2>&1 && fail "Error: tag $tag already exists"
 
-# Static code analysis and style checks, with less output
-[group('agent')]
-[no-exit-message]
-agent-check: agent-compile
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }} {{ _agent-check-body }}
-    end-safe && { {{ is_dependency() }} ||  echo OK; }
+    # Interactive confirmation (skip in dry-run)
+    if [[ "$DRY_RUN" == "false" ]]; then
+        while read -re -p "Release $release? [y/n] " answer; do
+            case "$answer" in
+                y|Y) break;;
+                n|N) exit 1;;
+                *) continue;;
+            esac
+        done
+    fi
 
-[private]
-_agent-check-body := '''
-    safe quiet $run_dev ruff format --check --quiet $python_dirs \
-    || { echo 'Try "just format"'; status=false; }
-    safe quiet $run_dev docformatter --check $python_dirs
-    safe quiet $run_dev ruff check --quiet --output-format=concise $python_dirs
-    safe quiet $run_dev mypy
-    safe quiet $run_dev make -C agents check
-'''
+    if [[ "$DRY_RUN" == "true" ]]; then
+        INITIAL_HEAD=$(git rev-parse HEAD)
+        INITIAL_BRANCH=$(git symbolic-ref -q --short HEAD || echo "")
+        trap 'cleanup_release "$INITIAL_HEAD" "$INITIAL_BRANCH" "${version:-}"; exit 1' ERR EXIT
+    fi
 
-# Ruff auto-fix
-[group('dev')]
-ruff-fix *ARGS:
-    {{ _run-dev }} ruff check --quiet --output-format=concise --fix \
-    {{ ARGS }} {{ _python-dirs }}
-
-# Reformat code, fail if formatting errors remain
-[group('dev')]
-format:
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }}
-    safe visible $run_dev ruff format $python_dirs
-    safe visible $run_dev ruff check --fix --unsafe-fixes --fix-only $python_dirs
-    safe visible $run_dev docformatter --in-place $python_dirs
-    end-safe
-
-# Create release: tag, build tarball, upload to PyPI and GitHub
-[group('dev')]
-release bump='patch': _fail_if_claudecode dev
-    #!/usr/bin/env bash -euo pipefail
-    {{ _bash-defs }}
-    ERROR="{{ style('error') }}"
-    GREEN=$'\033[32m'  # ansi code for green
-    fail () { echo "${ERROR}$*${NORMAL}"; exit 1; }
-    git diff --quiet HEAD || fail "Error: uncommitted changes"
-    release=$(uv version --bump {{ bump }} --dry-run)
-    while read -re -p "Release $release? [y/n] " answer; do
-        case "$answer" in
-            y|Y) break;;
-            n|N) exit 1;;
-            *) continue;;
-        esac
-    done
-    visible uv version --bump {{ bump }}
+    # Perform local changes: version bump, commit, build
+    visible uv version --bump "$BUMP"
     version=$(uv version)
     git add pyproject.toml uv.lock
     visible git commit -m "üîñ Release $version"
-    visible git push
     tag="v$(uv version --short)"
-    git rev-parse "$tag" >/dev/null 2>&1 \
-    && fail "Error: tag $tag already exists"
+    visible uv build
+
+    if [[ "$DRY_RUN" == "true" ]]; then
+        # Verify external permissions
+        git push --dry-run || fail "Error: cannot push to git remote"
+        [[ -z "${UV_PUBLISH_TOKEN:-}" ]] && fail "Error: UV_PUBLISH_TOKEN not set. Get token from https://pypi.org/manage/account/token/"
+        uv publish --dry-run dist/* || fail "Error: cannot publish to PyPI"
+        gh auth status >/dev/null 2>&1 || fail "Error: not authenticated with GitHub"
+
+        echo ""
+        echo "${GREEN}‚úì${NORMAL} Dry-run complete: $version"
+        echo "  ${GREEN}‚úì${NORMAL} Git push permitted"
+        echo "  ${GREEN}‚úì${NORMAL} PyPI publish permitted"
+        echo "  ${GREEN}‚úì${NORMAL} GitHub release permitted"
+
+        # Normal cleanup
+        trap - ERR EXIT
+        cleanup_release "$INITIAL_HEAD" "$INITIAL_BRANCH" "$version"
+        echo ""
+        echo "Run: ${COMMAND}just release $BUMP${NORMAL}"
+        exit 0
+    fi
+
+    # Perform external actions
+    visible git push
     visible git tag -a "$tag" -m "Release $version"
     visible git push origin "$tag"
-    visible uv build
     visible uv publish
-    visible gh release create "$tag" --title "Release $version" \
-        --generate-notes
-    echo "${GREEN}Release $tag complete${NORMAL}"
+    visible gh release create "$tag" --title "$version" --generate-notes
+    echo "${GREEN}‚úì${NORMAL} Release $tag complete"
 
-# Find new multi-line expressions for line-counter analysis
-[group('agent')]
-agent-new-multi:
-    uv run --dev scripts/find_multiline_exprs.py
+# Bash prolog
+[private]
+bash_prolog := \
+    ( if trace == "true" { "/usr/bin/env bash -xeuo pipefail" } \
+    else { "/usr/bin/env bash -euo pipefail" } ) + "\n" + '''
+COMMAND="''' + style('command') + '''"
+ERROR="''' + style('error') + '''"
+RED=$'\033[31m'
+GREEN=$'\033[32m'
+NORMAL="''' + NORMAL + '''"
+safe () { "$@" || status=false; }
+end-safe () { ${status:-true}; }
+show () { echo "$COMMAND$*$NORMAL"; }
+visible () { show "$@"; "$@"; }
+fail () { echo "${ERROR}$*${NORMAL}"; exit 1; }
+
+# Do not uv sync when in Claude Code sandbox
+sync() { test -w /tmp &&  uv sync -q "$@"; }
+
+HEADER_STYLE=$'\033[1;36m'  # Bold cyan
+report () {
+    # Usage: report "header" command args
+    header=$1; shift
+    if [[ ! -v tmpfile ]]; then
+        tmpfile=$(mktemp tmp/lint-XXXXXX)
+        trap "rm $tmpfile" EXIT
+    fi
+    safe "$@" > "$tmpfile"
+    if [ -s "$tmpfile" ]; then
+        echo "${HEADER_STYLE}# $header${NORMAL}"
+        cat "$tmpfile"
+    fi
+}
+'''
+
+# Fail if CLAUDECODE is set
+[no-exit-message]
+[private]
+_fail_if_claudecode:
+    #!{{ bash_prolog }}
+    if [ "${CLAUDECODE:-}" != "" ]; then
+        echo -e '{{ style("error") }}‚õîÔ∏è Denied: use agent recipes{{ NORMAL }}'
+        exit 1
+    fi
