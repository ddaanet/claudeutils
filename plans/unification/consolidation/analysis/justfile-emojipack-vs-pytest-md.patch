--- /Users/david/code/emojipack/justfile	2026-01-15 14:57:17
+++ /Users/david/code/pytest-md/justfile	2026-01-16 15:45:18
@@ -1,313 +1,269 @@
-[private]
-_ := require("uv")
+# Justfile Rules:
+# - Errors should not pass silently without good reason
+# - Only use `2>/dev/null` for probing (checking exit status when command has no quiet option)
+# - Only use `|| true` to continue after expected failures (required with `set -e`)
+# Enable bash tracing (set -x) for all recipes. Usage: just trace=true <recipe>
 
-# Import shared recipes from agent-core
-# Using absolute path for testing (will use relative path with actual submodule)
-import '/Users/david/code/agent-core/fragments/justfile-base.just'
+trace := "false"
 
-# Variables required by imported recipes
-SRC_DIR := "src"
-TEST_DIR := "tests"
-VENV := ".venv"
+# List available recipes
+help:
+    @just --list --unsorted
 
-# Display available recipes
-# Commented out - using imported help recipe from agent-core instead
-# [default]
-# [group('general')]
-# help:
-#     @just --list --unsorted
+# Full development workflow
+[no-exit-message]
+dev: format check test
 
-# Test local recipe execution: project-specific recipe alongside imported ones
-[group('testing')]
-test-local:
-    @echo "emojipack project-specific recipe executed (works alongside imported recipes)"
+# Run test suite
+[no-exit-message]
+test *ARGS:
+    #!{{ bash_prolog }}
+    sync
+    pytest {{ ARGS }}
 
-# Generate Emoji Pack
-[group('general')]
-build:
-    mkdir -p build
-    cd build; uv run emojipack generate
-    cd build; uv run emojipack generate --macos
+# Run token efficiency benchmark
+[no-exit-message]
+benchmark MODULE="tests/examples.py":
+    #!{{ bash_prolog }}
+    sync
+    python scripts/benchmark.py {{ MODULE }}
 
-# Generate Emoji Pack and open with Alfred
-[group('general')]
-install: generate
-    open "build/Emoji Pack.alfredsnippets"
 
-[group('general')]
-generate *ARGS:
-    cd build; uv run emojipack generate {{ ARGS }}
-
-
-# Compare generated pack with Joel's pack
-[group('general')]
-compare: generate
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    if [ ! -f data/joel.alfredsnippets ]
-    then do-command curl --location --output data/joel.alfredsnippets \
-        "https://joelcalifa.com/blog/alfred-emoji-snippet-pack/Emoji%20Pack.alfredsnippets"
+# Format, check with complexity disabled, test
+[no-exit-message]
+lint: format
+    #!{{ bash_prolog }}
+    sync
+    ruff_ignores=C901,PLR0904,PLR0911,PLR0912,PLR0913,PLR0914,PLR0915,PLR0916,PLR0917,PLR1701,PLR1702
+    report "ruff check" ruff check -q --ignore=$ruff_ignores
+    report "docformatter -c" docformatter -c src tests
+    report "mypy" mypy
+    pytest_hack () {
+        # Bug: pytest -q exits 0 even if tests fail
+        pytest -q > "$tmpfile"
+        if grep -q "^Re-run failed: " "$tmpfile"; then
+            show "# pytest"
+            cat "$tmpfile"
+            return 1
+        fi
+    }
+    safe pytest_hack
+    if end-safe; then
+        echo "${GREEN}‚úì$NORMAL Lint clean"
+    else
+        echo "${RED}‚úó$NORMAL Lint failed"
+        false
     fi
-    do-command uv run emojipack compare data/joel.alfredsnippets "build/Emoji Pack.alfredsnippets"
 
-# Hack to perform string interpolation on variables. Render the content of
-# the variables in a just subprocess, passing in the is_dependency() value.
-# In the subprocess, is_dependency() is always false.
-# Usage: {{ functions }} {{ is_dependency() }} {{ inner }}
-inner := "false"
-functions := 'load-funcs () { source <(just _functions $2 $1); }; load-funcs '
+# Check code style
+[no-exit-message]
+check:
+    #!{{ bash_prolog }}
+    sync
+    show "# ruff check"
+    safe ruff check -q
+    show "# docformatter -c"
+    safe docformatter -c src tests
+    show "# mypy"
+    safe mypy
+    end-safe
 
-# Common functions for all recipes
-[group('internal')]
-[private]
-_functions isdep inner:
-    #!/bin/cat
-    # exit-with: run command and exit with original status
-    exit-with () { local s=$?; "$@"; exit $s; }
-    # style-* : set text style.
-    style-command () { echo -n "{{ style('command') }}"; }
-    style-warning () { echo -n "{{ style('warning')}}"; }
-    style-error () { echo -n "{{ style('error') }}"; }
-    style-okay () { echo -en '\033[1;92m'; }
-    style-reset () { echo -ne "{{ NORMAL }}"; }
-    # echo-style STYLE ARGS... : Print ARGS in with STYLE.
-    echo-style () {
-        # Uncomment following line to ignore style if stdout is not a tty.
-        # [ ! -t 1 ] && { shift; echo "$*"; return; }
-        "style-$1"; shift
-        echo -n "$*"; style-reset; echo
+# Format code
+format:
+    #!{{ bash_prolog }}
+    sync
+    tmpfile=$(mktemp tmp-fmt-XXXXXX)
+    trap "rm $tmpfile" EXIT
+    patch-and-print() {
+        patch "$@" | sed -Ene "/^patching file '/s/^[^']+'([^']+)'/\\1/p"
     }
-    do-command () {
-        local cmd=""
-        for arg in "$@"; do
-            cmd+=$(printf "%q " "$arg")
-        done
-        echo-style command "${cmd% }" >&2
-        "$@"
-    }
-    okay () { echo-style okay "‚úÖ ${*:-OK}" >&2; }
-    warning () { echo-style warning "‚ö†Ô∏è  $*" >&2; }
-    error () { echo-style error "‚ùå ${*:-FAIL}" >&2; }
-    # No success or error output when running as dependency.
-    if {{ isdep }} || {{ inner }}
-    then okay () { :; }; error () { :; }
-    fi
-    # add-status command ...: run command and add $? to status variable
-    # Can run multiple seqential commands, delaying failure.
-    add-status () { set +e; "$@"; (( status = ${status:-0} + $? )); set -e; }
-    # do-status: return the accumulated status
-    do-status () { return ${status:-0}; }
+    ruff check -q --fix-only --diff | patch-and-print >> "$tmpfile" || true
+    ruff format -q --diff | patch-and-print >> "$tmpfile" || true
+    # docformatter --diff applies the change *and* outputs the diff, so we need to
+    # reverse the patch (-R) and dry run (-C), and it prefixes the path with before and
+    # after (-p1 ignores the first component of the path). Hence `patch -RCp1`.
+    docformatter --diff src tests | patch-and-print -RCp1 >> "$tmpfile" || true
 
-# Display available styles
-[group('internal')]
-[private]
-colors:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    echo "Inline styles:"
-    for x in command warning error okay reset
-    do style-$x; echo -n "$x "
-    dones
-    echo
-    echo "Line styles:"
-    do-command command
-    for x in warning error okay
-    do $x $x
-    done
+    # Markdown formatting disabled for the moment.
 
-# Development workflow: test, check
-# Commented out - using imported dev recipe from agent-core instead
-# [group('developer')]
-# [no-exit-message]
-# dev:
-#     #!/usr/bin/env bash -euo pipefail
-#     {{ functions }} {{ is_dependency() }} {{ inner }}
-#     just inner=true check-compile || exit-with error
-#     add-status just inner=true test
-#     add-status just inner=true check
-#     do-status && okay "Development checks OK" || exit-with error
+    # Must find replacement for dprint that handles backticks correctly.
+    modified=$(sort --unique < "$tmpfile")
+    if [ -n "$modified" ] ; then
+        bold=$'\033[1m'; nobold=$'\033[22m'
+        red=$'\033[31m'; resetfg=$'\033[39m'
+        echo "${bold}${red}**Reformatted files:**"
+        echo "$modified" | sed "s|^|${bold}${red}  - ${nobold}${resetfg}|"
+    fi
 
-python_dirs := "src tests"
+# Create release: tag, build tarball, upload to PyPI and GitHub
+# Use --dry-run to perform local changes and verify external permissions without publishing
 
-# Remove caches and build files
-[group('developer')]
-clean:
-    find {{ python_dirs }} -type d -name '__pycache__' | xargs rm -rf
-    rm -rf .*_cache .venv build
-
-# Agent workflow: minimal output version of dev
-[group('agent')]
+# Use --rollback to revert local changes from a crashed dry-run
 [no-exit-message]
-agent:
-    #!/usr/bin/env bash -euo pipefail
-    # Do not reformat code in agent mode, to prevent desync with agent state.
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    quietly () {
-        style-command; echo -n "$1... "; shift
-        output=$("$@" >&1) \
-        && { style-okay; echo OK; style-reset; } \
-        || {
-            local s=$?
-            style-error; echo FAIL
-            style-reset; echo "${output}"
-            return $s
-        }
-    }
-    add-status quietly "Test suite" just inner=true agent-test
-    add-status quietly "Static analysis" just inner=true agent-check
-    add-status quietly "Code style" just inner=true agent-check-format
-    do-status && okay || exit-with error
+release *ARGS: _fail_if_claudecode dev
+    #!{{ bash_prolog }}
+    DRY_RUN=false
+    ROLLBACK=false
+    BUMP=patch
+    # Parse flags and positional args
+    for arg in {{ ARGS }}; do
+        case "$arg" in
+            --dry-run) DRY_RUN=true ;;
+            --rollback) ROLLBACK=true ;;
+            --*) fail "Error: unknown option: $arg" ;;
+            *) [[ -n "${positional:-}" ]] && fail "Error: too many arguments"
+               positional=$arg ;;
+        esac
+    done
+    [[ -n "${positional:-}" ]] && BUMP=$positional
 
-# Run test suite
-# Commented out - using imported test recipe from agent-core instead
-# [group('developer')]
-# [no-exit-message]
-# test *ARGS:
-#     uv run --dev pytest --no-header {{ ARGS }}
+    # Cleanup function: revert commit and remove build artifacts
+    cleanup_release() {
+        local initial_head=$1
+        local initial_branch=$2
+        local version=$3
+        visible git reset --hard "$initial_head"
+        if [[ -n "$initial_branch" ]]; then
+            visible git checkout "$initial_branch"
+        else
+            visible git checkout "$initial_head"
+        fi
 
-# Run test suite in agent mode (less output)
-[group('agent')]
-[no-exit-message]
-agent-test *ARGS:
-    @uv run --dev pytest --no-header --quiet --tb=short {{ ARGS }}
+        # Remove only this version's build artifacts
+        if [[ -n "$version" ]] && [[ -d dist ]]; then
+            find dist -name "*${version}*" -delete
+            [[ -d dist ]] && [[ -z "$(ls -A dist)" ]] && visible rmdir dist
+        fi
+    }
 
-# Static code analysis and style checks
-# Commented out - using imported check recipe from agent-core instead
-# [group('developer')]
-# [no-exit-message]
-# check:
-#     #!/usr/bin/env bash -euo pipefail
-#     {{ functions }} {{ is_dependency() }} {{ inner }}
-#     # if inner=true, recipe is being run by dev recipe,
-#     if ! {{ inner }}
-#     then just inner=true check-compile || exit-with error
-#     fi
-#     add-status just inner=true check-format
-#     add-status just inner=true check-ruff
-#     add-status just inner=true check-types
-#     do-status && okay Static analysis and format checks passed \
-#     || exit-with error
+    # Rollback mode
+    if [[ "$ROLLBACK" == "true" ]]; then
+        # Check if there's a release commit at HEAD
+        if git log -1 --format=%s | grep -q "üîñ Release"; then
+            # Verify no permanent changes (commit not pushed to remote)
+            # Skip check if HEAD is detached or has no upstream
+            if git symbolic-ref -q HEAD >/dev/null && git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
+                # We're on a branch with upstream - check if release commit is unpushed
+                if ! git log @{u}.. --oneline | grep -q "üîñ Release"; then
+                    fail "Error: release commit already pushed to remote"
+                fi
+            fi
 
-[private]
-[group('agent')]
-[no-exit-message]
-agent-check: agent-check-compile
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    add-status just inner=true agent-check-ruff
-    add-status just inner=true agent-check-types
-    do-status && okay || exit-with error
+            version=$(git log -1 --format=%s | grep -oP '(?<=Release ).*')
+            current_branch=$(git symbolic-ref -q --short HEAD || echo "")
+            cleanup_release "HEAD~1" "$current_branch" "$version"
+            echo "${GREEN}‚úì${NORMAL} Rollback complete"
+        else
+            fail "No release commit found"
+        fi
+        exit 0
+    fi
 
-# Check that all Python files compile
-[private]
-[group('developer')]
-[no-exit-message]
-check-compile:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    do-command uv run -m compileall -q {{ python_dirs }} \
-    && okay || exit-with error
+    # Check preconditions
+    git diff --quiet HEAD || fail "Error: uncommitted changes"
+    current_branch=$(git symbolic-ref -q --short HEAD || echo "")
+    [[ -z "$current_branch" ]] && fail "Error: not on a branch (HEAD is detached)"
+    main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
+    [[ "$current_branch" != "$main_branch" ]] && fail "Error: must be on $main_branch branch (currently on $current_branch)"
+    release=$(uv version --bump "$BUMP" --dry-run)
+    tag="v$(echo "$release" | awk '{print $NF}')"
+    git rev-parse "$tag" >/dev/null 2>&1 && fail "Error: tag $tag already exists"
 
-# Check that all Python files compile (less output)
-[private]
-[group('agent')]
-[no-exit-message]
-agent-check-compile:
-    @uv run -m compileall -q {{ python_dirs }}
+    # Interactive confirmation (skip in dry-run)
+    if [[ "$DRY_RUN" == "false" ]]; then
+        while read -re -p "Release $release? [y/n] " answer; do
+            case "$answer" in
+                y|Y) break;;
+                n|N) exit 1;;
+                *) continue;;
+            esac
+        done
+    fi
 
-# Ruff static analysis only
-[private]
-[group('developer')]
-[no-exit-message]
-check-ruff:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    do-command uv run --dev ruff check --quiet {{ python_dirs }} \
-    && okay "Ruff check passed" \
-    || exit-with error "Ruff check failed, try 'just ruff-fix' to fix"
+    if [[ "$DRY_RUN" == "true" ]]; then
+        INITIAL_HEAD=$(git rev-parse HEAD)
+        INITIAL_BRANCH=$(git symbolic-ref -q --short HEAD || echo "")
+        trap 'cleanup_release "$INITIAL_HEAD" "$INITIAL_BRANCH" "${version:-}"; exit 1' ERR EXIT
+    fi
 
+    # Perform local changes: version bump, commit, build
+    visible uv version --bump "$BUMP"
+    version=$(uv version)
+    git add pyproject.toml uv.lock
+    visible git commit -m "üîñ Release $version"
+    tag="v$(uv version --short)"
+    visible uv build
 
-# Ruff static analysis only (less output)
-[private]
-[group('agent')]
-[no-exit-message]
-agent-check-ruff:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    uv run --dev ruff check --quiet {{ python_dirs }} \
-    && okay || exit-with error "Ruff check failed, try 'just ruff-fix' to fix"
+    if [[ "$DRY_RUN" == "true" ]]; then
+        # Verify external permissions
+        git push --dry-run || fail "Error: cannot push to git remote"
+        [[ -z "${UV_PUBLISH_TOKEN:-}" ]] && fail "Error: UV_PUBLISH_TOKEN not set. Get token from https://pypi.org/manage/account/token/"
+        uv publish --dry-run dist/* || fail "Error: cannot publish to PyPI"
+        gh auth status >/dev/null 2>&1 || fail "Error: not authenticated with GitHub"
 
-# Ruff auto-fix (unsafe fixes enabled)
-# Commented out - using imported ruff-fix recipe from agent-core instead
-# [group('developer')]
-# [no-exit-message]
-# ruff-fix:
-#     #!/usr/bin/env bash -euo pipefail
-#     {{ functions }} {{ is_dependency() }} {{ inner }}
-#     do-command uv run --dev ruff check --fix --unsafe-fixes {{ python_dirs }} \
-#     && okay || exit-with error "Manual fix required"
+        echo ""
+        echo "${GREEN}‚úì${NORMAL} Dry-run complete: $version"
+        echo "  ${GREEN}‚úì${NORMAL} Git push permitted"
+        echo "  ${GREEN}‚úì${NORMAL} PyPI publish permitted"
+        echo "  ${GREEN}‚úì${NORMAL} GitHub release permitted"
 
-# Type checking with ty and mypy
-[group('developer')]
-[no-exit-message]
-check-types:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    do-command uv run --dev ty check && (
-        do-command uv run --dev mypy \
-        || exit-with warning "mypy found issues that ty did not"
-    ) \
-    && okay "Type checks passed" \
-    || exit-with error "Type check failed, manual fix required"
+        # Normal cleanup
+        trap - ERR EXIT
+        cleanup_release "$INITIAL_HEAD" "$INITIAL_BRANCH" "$version"
+        echo ""
+        echo "Run: ${COMMAND}just release $BUMP${NORMAL}"
+        exit 0
+    fi
 
-# Type checking with ty and mypy (less output)
-[private]
-[group('agent')]
-[no-exit-message]
-agent-check-types:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    # ty prints annoying output on success, it can be disabled with -q, but
-    # that completely disables error reporting.
-    quietly () { out=$("$@" 2>&1) || exit-with echo "$out"; }
-    quietly uv run --dev ty check --output-format=concise && (
-        uv run --dev mypy \
-        || exit-with warning "mypy found issues that ty did not"
-    ) && okay || exit-with error
+    # Perform external actions
+    visible git push
+    visible git tag -a "$tag" -m "Release $version"
+    visible git push origin "$tag"
+    visible uv publish
+    visible gh release create "$tag" --title "$version" --generate-notes
+    echo "${GREEN}‚úì${NORMAL} Release $tag complete"
 
-# Check code formatting
-[group('developer')]
-[no-exit-message]
-check-format:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    add-status do-command uv run --dev ruff format --check {{ python_dirs }}
-    add-status do-command uv run --dev docformatter --check {{ python_dirs }}
-    do-status && okay "Format checks passed" \
-    || exit-with error "Format check failed, try 'just format' to fix"
-
-# Check code formatting (less output)
+# Bash prolog
 [private]
-[group('agent')]
-[no-exit-message]
-agent-check-format:
-    #!/usr/bin/env bash -euo pipefail
-    {{ functions }} {{ is_dependency() }} {{ inner }}
-    add-status uv run --dev ruff format --quiet --check {{ python_dirs }}
-    add-status uv run --dev docformatter --check {{ python_dirs }}
-    do-status && okay \
-    || exit-with error "Format check failed, try 'just format' to fix"
+bash_prolog := \
+    ( if trace == "true" { "/usr/bin/env bash -xeuo pipefail" } \
+    else { "/usr/bin/env bash -euo pipefail" } ) + "\n" + '''
+COMMAND="''' + style('command') + '''"
+ERROR="''' + style('error') + '''"
+RED=$'\033[31m'
+GREEN=$'\033[32m'
+NORMAL="''' + NORMAL + '''"
+safe () { "$@" || status=false; }
+end-safe () { ${status:-true}; }
+show () { echo "$COMMAND$*$NORMAL"; }
+visible () { show "$@"; "$@"; }
+fail () { echo "${ERROR}$*${NORMAL}"; exit 1; }
 
-# Reformat code, fail if formatting errors remain
-# Commented out - using imported format recipe from agent-core instead
-# [group('developer')]
-# [no-exit-message]
-# format:
-#     #!/usr/bin/env bash -euo pipefail
-#     {{ functions }} {{ is_dependency() }} {{ inner }}
-#     add-status do-command uv run --dev ruff format {{ python_dirs }}
-#     add-status do-command \
-#         uv run --dev docformatter --in-place {{ python_dirs }}
-#     do-status && okay Code format OK || exit-with error Code format failed
+# Do not uv sync when in Claude Code sandbox
+sync() { test -w /tmp &&  uv sync -q "$@"; }
 
+HEADER_STYLE=$'\033[1;36m'  # Bold cyan
+report () {
+    # Usage: report "header" command args
+    header=$1; shift
+    if [[ ! -v tmpfile ]]; then
+        tmpfile=$(mktemp tmp/lint-XXXXXX)
+        trap "rm $tmpfile" EXIT
+    fi
+    safe "$@" > "$tmpfile"
+    if [ -s "$tmpfile" ]; then
+        echo "${HEADER_STYLE}# $header${NORMAL}"
+        cat "$tmpfile"
+    fi
+}
+'''
 
+# Fail if CLAUDECODE is set
+[no-exit-message]
+[private]
+_fail_if_claudecode:
+    #!{{ bash_prolog }}
+    if [ "${CLAUDECODE:-}" != "" ]; then
+        echo -e '{{ style("error") }}‚õîÔ∏è Denied: use agent recipes{{ NORMAL }}'
+        exit 1
+    fi
