# Orchestrate Evolution — Design Outline

## Approach

Evolve the orchestrate skill into an enhanced execution orchestrator. Sonnet replaces haiku. Plan-specific agents cache all common context (design + runbook outline) so implementation agents receive only their step file as non-cached input. Parallel dispatch, post-step remediation, and agent caching model replace the current weak orchestration pattern.

Planning orchestration is out of scope — plan-tdd and plan-adhoc remain independent skills. Sub-agent limitations (no MCP, no nested Task) make planning delegation impractical for exploration-heavy steps.

## Key Decisions

### D-1: Abandon weak orchestration, sonnet default

**Current:** Haiku orchestrator. Many learnings are band-aids for haiku's inability to recover from failures.

**Decision:** Sonnet as default orchestrator model.

**What changes:**
- Orchestrate skill assumes sonnet-level reasoning
- Error escalation: sonnet → user (2 levels)
- Post-step remediation possible (sonnet can commit/fix, not just stop)
- "Delegate, don't decide" relaxed to "delegate execution, handle exceptions"

**What stays the same:**
- Mechanical checks remain mechanical (UNFIXABLE grep, git status, precommit)
- Agents do the work, orchestrator coordinates
- Step files, orchestrator plans, plan-specific agents preserved

### D-2: Agent caching model

**Current:** Orchestrator reads step file content, passes it in Task prompt. Bloats orchestrator context.

**Decision:** All common context lives in the plan-specific agent definition (cached via prompt prefix). Orchestrator prompt contains only the step file reference (non-cached).

**Plan-specific agent types (generated by prepare-runbook.py):**
- `<plan>-task.md` — implementation agent: embedded design.md + runbook outline
- `<plan>-vet.md` — vet-fix agent: embedded design.md + runbook outline (multi-phase plans only)

This produces one or two agent types per plan (task always, vet for multi-phase only).

**Embedded content:** The agent definition includes the full text of design.md and runbook outline. This content is cached by prompt prefix matching — loaded once, reused across all step invocations.

**Orchestrator prompt shrinks to:**
```
Execute: plans/<name>/steps/step-N.md
```

**Commit requirement:** Agent definition includes "Clean tree requirement" footer. Orchestrator doesn't repeat it.

**Scope enforcement:** Agent definition includes "Execute ONLY this step" constraint. Combined with not providing other step files, creates structural + prose scope boundary.

**What this eliminates:**
- Orchestrator reading step files or design docs
- Orchestrator generating prompts with inline content
- Context growth proportional to step count
- Separate prompt deduplication mechanism (D-6 from prior version — agent definitions ARE deduplication)

**Context tiers as agent selection:**

| Role | Agent | Non-cached input |
|---|---|---|
| Implementation | `<plan>-task.md` | Step file reference |
| Review | `<plan>-vet.md` | Step file + changed files |
| Recovery | `<plan>-task.md` (resumed) or sonnet default | Step file + git diff |

Review agents get the same cached context (design + outline) but receive additional non-cached input (changed files list) for alignment checking.

### D-3: Post-step verify-remediate protocol

**Decision:** Resume step agent first, delegate recovery on failure or context overflow.

**Protocol:**
1. `git status --porcelain` + `just precommit` — if both clean, proceed
2. If dirty: resume step agent to fix and commit (it has context)
3. If step agent context > 100k tokens: skip resume, delegate recovery directly (Orchestrator needs context measurement: message count × avg tokens, or API-based check)
4. If resumed step agent failed to fix: delegate recovery
5. Recovery agent: sonnet agent with full context (step file reference + git diff + design + outline from task agent, plus runtime error state), goal = lint-clean + git-clean
6. After any remediation: generate RCA pending task in session.md
7. If recovery fails: escalate to user

**Verification script:** Skill-local script (new deliverable, lives with orchestrate skill) for orchestrator to call after each implementation step. Checks git clean + precommit clean efficiently.

### D-4: Simplified error escalation

**Decision:** sonnet → user (2 levels)
- Sonnet orchestrator handles execution-level issues inline (missing files, failed commands, dirty tree)
- Design-level issues escalate to user (wrong approach, scope change, blocking ambiguity)

## Resolved Questions

### Q-1: Planning absorption → Dropped

**Decision:** No planning orchestration. Orchestrate handles execution only.

**Rationale:**
- Sub-agents cannot spawn sub-agents (no nested Task), cannot use MCP tools — limits planning delegation
- Design generation requires exploration and external doc access (main-session capabilities)
- Planning runs once per job; execution runs 20+ times — optimize execution first
- plan-tdd and plan-adhoc work well as independent main-session skills
- Future enhancement: add planning orchestration once execution patterns proven

### Q-2: Plan-specific agents → Keep with cleanup

**Decision:** Keep plan-specific agents with enhanced caching model (D-2). Up to two agent types per plan: `<plan>-task.md` (implementation) and `<plan>-vet.md` (review, multi-phase only).

Cleanup step after orchestration completes (orchestrate skill final step): delete `.claude/agents/<plan>-task.md` and `<plan>-vet.md`.

### Q-3: Remediation authority → Resume step agent with fallback

**Decision:** Resume original step agent first (it has context for fixing its own issues). See D-3 for full protocol.

**Summary:** Resume step agent for remediation, fallback to recovery if context > 100k or resume fails. Recovery uses sonnet agent with full context.

### Q-4: Backwards compatibility → Clean break

**Decision:** No backwards compatibility. New prepare-runbook.py generates new format. Old orchestrator plans must be regenerated.

**Rationale:** No active orchestrator plans need preservation. All in-progress plans can regenerate artifacts cheaply.

## Key Orchestration Principles

Binding constraints for the design:

**Agent caching principle:**
- All common context required by implementation agents lives in the agent definition (cached)
- The only non-cached context is the step file reference
- If review agents need different shared context, they get a separate agent definition (`<plan>-vet.md`)
- No phase-specific agent variants — up to two agent types per plan (task always, vet for multi-phase only)
- Recovery reuses task agent (resumed) or sonnet default agent (not a third plan-specific type)

**Orchestrator bloat prevention:**
- Orchestrator provides step file references only — never reads step/design/outline content
- Orchestrator reads only agent return messages, not report content
- Orchestrator forwards report paths to recovery agents without reading reports

**Post-step verification:**
- Git clean + precommit clean after each implementation step
- Script-based (skill-local script) for efficiency
- Complexity fixes (refactor agent) and vet-fix at end of each phase
- Tree must be git-clean and precommit-clean at end of each phase

**Refactor agent behavior:**
- Resume once if complexity errors not fully fixed and context < 100k (same pattern as D-3)
- If resumed refactor agent fails or context > 100k: delegate recovery
- Must include detailed deslop directives
- Before splitting files: first remove slop and factor duplication — splitting is last resort

## Scope

**In scope:**
- Orchestrate skill (SKILL.md) — rewrite with enhanced execution, agent caching, cleanup
- prepare-runbook.py — generate plan-specific agents with embedded design+outline, sequential execution order
- Plan-specific agent templates — `<plan>-task.md` and `<plan>-vet.md` with cached content
- delegation.md — update for new patterns
- Orchestrator plan format — sequential execution order, file reference metadata
- Orchestrate skill verification script — post-step check (git clean + precommit)
- Refactor agent — add deslop directives, factorization-before-splitting rule, resume pattern

**Out of scope:**
- Planning orchestration (plan-tdd / plan-adhoc stay as independent skills)
- Parallel execution (deferred to `plans/parallel-orchestration/`, requires worktree isolation)
- Worktree-specific orchestration
- vet-fix-agent changes (beyond plan-specific vet agent generation)
- Continuation passing integration (preserved — already complete)
